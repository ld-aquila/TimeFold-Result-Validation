= TimeFold Application Cross-Architecture Validation
:toc: left
:icons: font
:source-highlighter: coderay
:sectnums:

== Goal of the Experiment

The purpose of this experiment is to validate whether the TimeFold application behaves consistently across different hardware architectures (Intel, AMD, Mac) when run with identical CPU specifications (e.g., same number of cores, threads, and resources). This validation is essential because other applications have exhibited inconsistent behavior across different architectures despite having the same configurations. We are using TimeFold as a test case to determine whether it produces reliable and consistent results across architectures.

== Requirements & Prerequisites

=== Hardware
- Machines with different architectures:
- Intel-based machine
- AMD-based machine
- Mac machine (ARM-based)

=== Software
- Docker installed on all machines to create consistent environments across architectures.
- JDK 21 installed within the Docker environment.
- Clone the repository from the following link: https://github.com/ld-aquila/TimeFold-Result-Validation/blob/stable/java/vehicle-routing/README.adoc

=== Other Dependencies
- Ensure that each machine has equivalent Docker environments, with identical CPU, RAM, and Java heap size specifications.

== How to Run the Application

To install and run the TimeFold application, please follow the instructions provided in the official TimeFold Vehicle Routing README at https://github.com/ld-aquila/TimeFold-Result-Validation/blob/stable/java/vehicle-routing/README.adoc.

=== General Steps
1. Set up the Docker environment on each machine.
2. Run the application inside the Docker container on each architecture machine using the guide.
3. Ensure that all configurations (e.g., Java heap size, CPU cores) are consistent across all machines.

== What Was Changed in This App Compared to the Original Example

=== Result Storage
- Two files are generated for each `jobId` in the `java/vehicle-routing/src/main/resources/results` directory:
- A file with the exact `jobId` name contains details about the CPU, RAM, Java heap size, and their utilization.
- A second file, prefixed with `score-explanation-` followed by the `jobId`, stores the score explanation results and the visit/vehicle routing data in text format.

=== Cross-Architecture Validation
- The application is modified to gather performance data and validate the consistency of results across different architectures.

== Where Are the Results Stored?

The results of the experiment are stored in the following directory:

[source, bash]
----
/home/jboss/src/main/resources/results
----

=== Files
- **`jobId`**: Contains details about CPU, RAM, Java heap size, and utilization for the run on a particular architecture.
- **`score-explanation-jobId`**: Contains the score explanation and the vehicle routing results in text form.

== How to Read the Results

=== CPU, RAM, Java Heap Utilization
- Open the file with the exact `jobId` name in the `results` directory. This file contains information about the CPU architecture, RAM usage, and Java heap size/utilization.

=== Score Explanation & Visit/Vehicle Details
- Open the file prefixed with `score-explanation-` followed by the `jobId`. This file contains details of the score explanation and the solution for vehicle routing, including the sequence of visits per vehicle.

== Discussion

This experiment evaluates the performance and consistency of the TimeFold application across different architectures (Intel, AMD, Mac) under the same configuration. The goal is to validate that TimeFold produces consistent results across different architectures, unlike other applications that have shown discrepancies.

By examining CPU, RAM, and Java heap utilization and comparing the routing results, we can determine if architecture has any significant impact on the outcome. This validation is crucial for understanding the cross-architecture behavior of TimeFold and confirming its reliability in diverse hardware environments.
